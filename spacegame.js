// Generated by CoffeeScript 1.6.3
(function() {
  var BaseEntity, Enemy_Ship, Enemy_Shot, Game, Killable, Particle, Player, Player_Shot, Shot, Star, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseEntity = (function() {
    function BaseEntity() {
      var _base;
      this.game = window.Game;
      this.container = (_base = this.constructor).container != null ? (_base = this.constructor).container : _base.container = [];
      this.index = this.container.length;
      this.container.push(this);
      if (this.mass == null) {
        this.mass = (this.dims[0] * this.dims[1] / 4) | 0;
      }
      if (this.size == null) {
        this.size = this.dims[0];
      }
    }

    BaseEntity.prototype.update_pos = function() {
      this.pos[0] += this.vector[0];
      this.pos[1] += this.vector[1];
      if (this.out_of_bounds()) {
        return this.destroy();
      } else {
        return this.render();
      }
    };

    BaseEntity.prototype.update = function() {
      this.update_pos();
      return this.act();
    };

    BaseEntity.prototype.destroy = function() {
      this.container[this.index] = this.container[this.container.length - 1];
      this.container[this.index].index = this.index;
      this.container.pop();
      return this.explode(this.pos, this.mass);
    };

    BaseEntity.prototype.out_of_bounds = function() {
      var tolerance, x, y, _ref;
      _ref = this.pos, x = _ref[0], y = _ref[1];
      tolerance = this.dims[0];
      return x < -tolerance || y < -tolerance || x > this.game.width + tolerance || y > this.game.height + tolerance;
    };

    BaseEntity.prototype.collides = function(entity) {
      var min_dist, x1, x2, y1, y2, _ref, _ref1;
      _ref = this.pos, x1 = _ref[0], y1 = _ref[1];
      _ref1 = entity.pos, x2 = _ref1[0], y2 = _ref1[1];
      min_dist = (this.size + entity.size) / 2;
      return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2) < Math.pow(min_dist, 2);
    };

    BaseEntity.prototype.render = function() {
      return this.rect(this.pos, this.dims);
    };

    BaseEntity.prototype.rect = function() {
      var dx, dy, x, y, _ref, _ref1;
      _ref = this.pos, x = _ref[0], y = _ref[1];
      _ref1 = this.dims, dx = _ref1[0], dy = _ref1[1];
      return this.game.ctx.fillRect((x - dx / 2) | 0, (y - dy / 2) | 0, dx | 0, dy | 0);
    };

    BaseEntity.prototype.act = function() {};

    BaseEntity.prototype.explode = function(pos, power) {
      var angle, blast, e, xspeed, yspeed, _results;
      e = power;
      _results = [];
      while (e-- > 0) {
        angle = Math.random() * Math.PI * 2;
        blast = Math.random() * Math.sqrt(power) / 4;
        xspeed = Math.cos(angle) * blast;
        yspeed = Math.sin(angle) * blast;
        _results.push(new Particle(pos.slice(0), [xspeed, yspeed]));
      }
      return _results;
    };

    return BaseEntity;

  })();

  Particle = (function(_super) {
    __extends(Particle, _super);

    Particle.container = [];

    function Particle(pos, vector) {
      this.pos = pos;
      this.vector = vector;
      this.dims = [2, 2];
      this.mass = 0;
      Particle.__super__.constructor.apply(this, arguments);
    }

    Particle.prototype.act = function() {
      if (Math.random() < .1) {
        return this.destroy();
      }
    };

    return Particle;

  })(BaseEntity);

  Star = (function(_super) {
    __extends(Star, _super);

    Star.container = [];

    function Star(xpos) {
      this.pos = [xpos, -1];
      this.vector = [0, 6];
      this.dims = [1, 2];
      this.mass = 0;
      Star.__super__.constructor.apply(this, arguments);
    }

    return Star;

  })(BaseEntity);

  Shot = (function(_super) {
    __extends(Shot, _super);

    function Shot() {
      _ref = Shot.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Shot.prototype.act = function() {
      this.collide_with_enemies();
      return this.explode(this.pos, 1);
    };

    Shot.prototype.collide_with_enemies = function() {
      var e, _results;
      e = this.enemies.length;
      _results = [];
      while (e-- > 0) {
        if (this.collides(this.enemies[e])) {
          this.damage(this.enemies[e]);
          this.destroy();
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Shot.prototype.damage = function(entity) {
      return entity.hit();
    };

    return Shot;

  })(BaseEntity);

  Player_Shot = (function(_super) {
    __extends(Player_Shot, _super);

    Player_Shot.container = [];

    function Player_Shot(pos, xspd) {
      this.pos = pos;
      this.vector = [xspd, -8];
      if (this.dims == null) {
        this.dims = [3, 10];
      }
      this.enemies = Enemy_Ship.container;
      Player_Shot.__super__.constructor.apply(this, arguments);
    }

    Player_Shot.prototype.damage = function(entity) {
      Player_Shot.__super__.damage.apply(this, arguments);
      return this.inc_score();
    };

    Player_Shot.prototype.inc_score = function() {
      this.game.killcount++;
      return this.game.player.mass += 10;
    };

    return Player_Shot;

  })(Shot);

  Enemy_Shot = (function(_super) {
    __extends(Enemy_Shot, _super);

    Enemy_Shot.container = [];

    function Enemy_Shot(pos, vector) {
      this.pos = pos;
      this.vector = vector;
      this.dims = [3, 10];
      this.enemies = Player.container;
      Enemy_Shot.__super__.constructor.apply(this, arguments);
    }

    Enemy_Shot.prototype.damage = function(entity) {
      Enemy_Shot.__super__.damage.apply(this, arguments);
      return this.explode(this.pos, 50);
    };

    return Enemy_Shot;

  })(Shot);

  Killable = (function(_super) {
    __extends(Killable, _super);

    function Killable() {
      if (this.max_health == null) {
        this.max_health = 1;
      }
      this.health = this.max_health;
      Killable.__super__.constructor.apply(this, arguments);
    }

    Killable.prototype.hit = function() {
      if (--this.health <= 0) {
        return this.destroy();
      }
    };

    return Killable;

  })(BaseEntity);

  Enemy_Ship = (function(_super) {
    __extends(Enemy_Ship, _super);

    Enemy_Ship.container = [];

    function Enemy_Ship(pos, vector, cooldown) {
      this.pos = pos;
      this.vector = vector;
      this.cooldown = cooldown;
      this.dims = [25, 25];
      this.enemies = Player.container;
      Enemy_Ship.__super__.constructor.apply(this, arguments);
    }

    Enemy_Ship.prototype.act = function() {
      this.collide_with_enemies();
      if (this.cooldown-- <= 0) {
        return this.spawn_shot();
      }
    };

    Enemy_Ship.prototype.spawn_shot = function() {
      var new_shot;
      this.cooldown = 60;
      new_shot = new Enemy_Shot(this.pos.slice(0), [0, 6]);
      return new_shot.pos[1] += this.size / 2;
    };

    Enemy_Ship.prototype.collide_with_enemies = function() {
      var e, _results;
      e = this.enemies.length;
      _results = [];
      while (e-- > 0) {
        if (this.collides(this.enemies[e])) {
          this.damage(this.enemies[e]);
          this.destroy();
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Enemy_Ship.prototype.damage = function(entity) {
      return entity.hit();
    };

    Enemy_Ship.prototype.render = function() {
      return this.game.dispImg(this.game.shipimg, this.pos);
    };

    return Enemy_Ship;

  })(Killable);

  Player = (function(_super) {
    __extends(Player, _super);

    Player.container = [];

    function Player() {
      if (this.dims == null) {
        this.dims = [25, 25];
      }
      if (this.pos == null) {
        this.pos = [320, 350];
      }
      this.enemies = Enemy_Ship.container;
      if (this.mass == null) {
        this.mass = 500;
      }
      if (this.max_health == null) {
        this.max_health = 3;
      }
      this.cooldown = 0;
      Player.__super__.constructor.apply(this, arguments);
    }

    Player.prototype.update_pos = function() {
      var dirs, key, x, y, _ref1;
      _ref1 = this.pos, x = _ref1[0], y = _ref1[1];
      dirs = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.game.keypress;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          _results.push(key != null ? key : {
            1: 0
          });
        }
        return _results;
      }).call(this);
      x += 4 * (dirs[2] - dirs[0]);
      y += 4 * (dirs[3] - dirs[1]);
      x = this.buffer(x, this.size / 2, this.game.width - this.size / 2);
      y = this.buffer(y, this.size / 2, this.game.height - this.size / 2);
      this.pos = [x, y];
      return this.render();
    };

    Player.prototype.buffer = function(index, left, right) {
      if (index < left) {
        return left;
      }
      if (index > right) {
        return right;
      }
      return index;
    };

    Player.prototype.act = function() {
      if (this.cooldown-- <= 0 && this.game.keypress[4]) {
        return this.spawn_shot();
      }
    };

    Player.prototype.spawn_shot = function() {
      var a, killcount, left, right, shoty, side_length, x, y, _ref1, _results;
      this.cooldown = 30;
      _ref1 = this.pos, x = _ref1[0], y = _ref1[1];
      side_length = this.size / 2;
      shoty = y - side_length;
      left = x - side_length;
      right = x + side_length;
      killcount = this.game.killcount;
      if (killcount >= 70) {
        this.cooldown = 0;
        return new Player_Shot([x, shoty], Math.random() - .5);
      } else if (killcount >= 45) {
        a = 5;
        _results = [];
        while (a-- > 0) {
          _results.push(new Player_Shot([x, shoty], a - 2));
        }
        return _results;
      } else if (killcount >= 25) {
        new Player_Shot([left, y], -1);
        new Player_Shot([x, shoty], 0);
        return new Player_Shot([right, y], 1);
      } else if (killcount >= 10) {
        new Player_Shot([left, y], 0);
        return new Player_Shot([right, y], 0);
      } else {
        return new Player_Shot([x, shoty], 0);
      }
    };

    Player.prototype.render = function() {
      return this.game.dispImg(this.game.pcimg, this.pos);
    };

    Player.prototype.destroy = function() {
      Player.__super__.destroy.apply(this, arguments);
      return this.game.restart();
    };

    Player.prototype.hit = function() {
      this.explode([27 + 15 * this.health, this.game.height - 10], 50);
      return Player.__super__.hit.apply(this, arguments);
    };

    return Player;

  })(Killable);

  Game = (function() {
    function Game() {
      var _this = this;
      this.canvas = document.getElementById('game');
      this.ctx = this.canvas.getContext('2d');
      this.width = this.canvas.width;
      this.height = this.canvas.height;
      this.pcimg = this.srcimg('MqaLKP2');
      this.meteorimg = this.srcimg('ChDuBLO');
      this.bigmeteorimg = this.srcimg('tIyQv1V');
      this.shipimg = this.srcimg('SbyapXR');
      this.bigshipimg = this.srcimg('nzSFj9X');
      this.armorimg = this.srcimg('pXRIDRB');
      this.all_entities = [['white', Star], ['grey', Particle], ['white', Player_Shot], ['red', Enemy_Shot], ['white', Enemy_Ship], ['white', Player]];
      this.keypress = [false, false, false, false, false];
      this.paused = false;
      this.killcount = 0;
      this.spawntime = 60;
      this.spawner = 0;
      this.stargen = 0;
      this.canvas.addEventListener('keydown', function(e) {
        return _this.handleKeys(e);
      });
      this.canvas.addEventListener('keyup', function(e) {
        return _this.handleKeys(e);
      });
      window.requestAnimFrame(function() {
        return _this.game_loop();
      });
    }

    Game.prototype.srcimg = function(src) {
      var img;
      img = document.createElement('img');
      img.src = 'http://i.imgur.com/' + src + '.png';
      return img;
    };

    Game.prototype.game_loop = function() {
      var _this = this;
      if (this.paused) {
        return;
      }
      if (Player.container.length === 0) {
        this.player = new Player();
      }
      window.requestAnimFrame(function() {
        return _this.game_loop();
      });
      this.increment_spawning();
      this.ctx.clearRect(0, 0, this.width, this.height);
      this.renderEntities();
      return this.renderText();
    };

    Game.prototype.renderText = function() {
      var a, _results;
      this.ctx.fillStyle = 'white';
      this.ctx.textAlign = 'left';
      this.ctx.fillText('kills: ' + this.killcount, 5, 13);
      this.ctx.fillText('armor: ', 5, this.height - 6);
      this.ctx.fillStyle = 'grey';
      a = this.player.health;
      _results = [];
      while (a-- > 0) {
        _results.push(this.dispImg(this.armorimg, [42 + 15 * a, this.height - 10]));
      }
      return _results;
    };

    Game.prototype.renderEntities = function() {
      var group, _i, _len, _ref1, _results;
      _ref1 = this.all_entities;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        group = _ref1[_i];
        _results.push(this.render_group(group));
      }
      return _results;
    };

    Game.prototype.render_group = function(_arg) {
      var a, base_class, color, group, _results;
      color = _arg[0], base_class = _arg[1];
      this.ctx.fillStyle = color;
      group = base_class.container;
      a = group.length;
      _results = [];
      while (a-- > 0) {
        _results.push(group[a].update());
      }
      return _results;
    };

    Game.prototype.restart = function() {
      Player_Shot.container = [];
      Enemy_Shot.container = [];
      Enemy_Ship.container = [];
      Player.container = [];
      this.player = new Player();
      return this.killcount = 0;
    };

    Game.prototype.dispImg = function(img, pos) {
      var center_x, center_y;
      center_x = pos[0] - img.width / 2;
      center_y = pos[1] - img.height / 2;
      return this.ctx.drawImage(img, (center_x | 0) + .5, (center_y | 0) + .5);
    };

    Game.prototype.increment_spawning = function() {
      var shot_offset, x, x_speed, y, y_speed;
      this.spawner--;
      if (this.spawner <= 0) {
        if (this.killcount >= 40) {
          this.spawner = this.spawntime / 4;
        } else if (this.killcount >= 15) {
          this.spawner = this.spawntime / 2;
        } else {
          this.spawner = this.spawntime;
        }
        x = Math.random() * (this.width - 25) + 25 / 2;
        y = -25 / 2;
        x_speed = .6 * Math.random() - .3;
        y_speed = 1.5;
        shot_offset = 30 + Math.random() * 60;
        new Enemy_Ship([x, y], [x_speed, y_speed], shot_offset);
      }
      return new Star(Math.random() * this.width);
    };

    Game.prototype.handleKeys = function(event) {
      var a, down;
      down = event.type === 'keydown';
      a = -1;
      switch (event.keyCode) {
        case 37:
        case 65:
          a = 0;
          break;
        case 38:
        case 87:
          a = 1;
          break;
        case 39:
        case 68:
          a = 2;
          break;
        case 40:
        case 83:
          a = 3;
          break;
        case 32:
        case 76:
          a = 4;
      }
      if (down) {
        switch (event.keyCode) {
          case 80:
            this.toggle_pause();
            break;
          case 82:
            this.restart();
        }
      }
      if (a >= 0) {
        this.keypress[a] = down;
      }
      event.preventDefault();
      return event.stopPropagation();
    };

    Game.prototype.toggle_pause = function() {
      var _this = this;
      this.paused = !this.paused;
      if (this.paused) {
        this.ctx.fillStyle = 'white';
        return this.ctx.fillText('-paused-', this.width / 2 + 20, this.height / 2 + 5);
      } else {
        return window.requestAnimFrame(function() {
          return _this.game_loop();
        });
      }
    };

    return Game;

  })();

  window.requestAnimFrame = requestAnimationFrame || webkitRequestAnimationFrame || mozRequestAnimationFrame || oRequestAnimationFrame || msRequestAnimationFrame || function(callback, element) {
    return setTimeout(callback, 1000 / 60);
  };

  window.Game = new Game();

}).call(this);
