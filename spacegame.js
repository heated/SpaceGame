// Generated by CoffeeScript 1.6.3
(function() {
  var BaseEntity, Enemy_Ship, Enemy_Shot, Killable, Particle, Player, Player_Shot, Shot, Star, all_entities, allies, armorimg, bigmeteorimg, bigshipimg, canvas, ctx, dispImg, enemy_attacks, enemy_mobs, game_loop, handleKeys, increment_spawning, keypress, killcount, meteorimg, particles, paused, pcimg, player, player_attacks, renderEntities, renderText, render_group, restart, shipimg, spawner, spawntime, srcimg, stargen, stars, toggle_pause, _ref,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseEntity = (function() {
    function BaseEntity() {
      this.index = this.container.length;
      this.container.push(this);
      if (this.mass == null) {
        this.mass = (this.dims[0] * this.dims[1] / 4) | 0;
      }
      if (this.size == null) {
        this.size = this.dims[0];
      }
    }

    BaseEntity.prototype.update_pos = function() {
      this.pos[0] += this.vector[0];
      this.pos[1] += this.vector[1];
      if (this.out_of_bounds()) {
        return this.destroy();
      } else {
        return this.render();
      }
    };

    BaseEntity.prototype.update = function() {
      this.update_pos();
      return this.act();
    };

    BaseEntity.prototype.destroy = function() {
      this.container[this.index] = this.container[this.container.length - 1];
      this.container[this.index].index = this.index;
      this.container.pop();
      return this.explode(this.pos, this.mass);
    };

    BaseEntity.prototype.out_of_bounds = function() {
      var tolerance, x, y, _ref;
      _ref = this.pos, x = _ref[0], y = _ref[1];
      tolerance = this.dims[0];
      return x < -tolerance || y < -tolerance || x > canvas.width + tolerance || y > canvas.height + tolerance;
    };

    BaseEntity.prototype.collides = function(entity) {
      var min_dist, x1, x2, y1, y2, _ref, _ref1;
      _ref = this.pos, x1 = _ref[0], y1 = _ref[1];
      _ref1 = entity.pos, x2 = _ref1[0], y2 = _ref1[1];
      min_dist = this.size / 2 + entity.size / 2;
      return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2) < Math.pow(min_dist, 2);
    };

    BaseEntity.prototype.render = function() {
      return this.rect(this.pos, this.dims);
    };

    BaseEntity.prototype.rect = function() {
      var dx, dy, x, y, _ref, _ref1;
      _ref = this.pos, x = _ref[0], y = _ref[1];
      _ref1 = this.dims, dx = _ref1[0], dy = _ref1[1];
      return ctx.fillRect((x - dx / 2) | 0, (y - dy / 2) | 0, dx | 0, dy | 0);
    };

    BaseEntity.prototype.act = function() {};

    BaseEntity.prototype.explode = function(pos, power) {
      var angle, blast, e, xspeed, yspeed, _results;
      e = power;
      _results = [];
      while (e-- > 0) {
        angle = Math.random() * Math.PI * 2;
        blast = Math.random() * Math.sqrt(power) / 4;
        xspeed = Math.cos(angle) * blast;
        yspeed = Math.sin(angle) * blast;
        _results.push(new Particle(__slice.call(pos), [xspeed, yspeed]));
      }
      return _results;
    };

    return BaseEntity;

  })();

  Particle = (function(_super) {
    __extends(Particle, _super);

    function Particle(pos, vector) {
      this.pos = pos;
      this.vector = vector;
      this.dims = [2, 2];
      this.container = particles;
      this.mass = 0;
      Particle.__super__.constructor.apply(this, arguments);
    }

    Particle.prototype.act = function() {
      if (Math.random() < .1) {
        return this.destroy();
      }
    };

    return Particle;

  })(BaseEntity);

  Star = (function(_super) {
    __extends(Star, _super);

    function Star(xpos) {
      this.pos = [xpos, -1];
      this.vector = [0, 5];
      this.dims = [1, 2];
      this.container = stars;
      this.mass = 0;
      Star.__super__.constructor.apply(this, arguments);
    }

    return Star;

  })(BaseEntity);

  Killable = (function(_super) {
    __extends(Killable, _super);

    function Killable() {
      if (this.max_health == null) {
        this.max_health = 1;
      }
      this.health = this.max_health;
      Killable.__super__.constructor.apply(this, arguments);
    }

    Killable.prototype.hit = function() {
      if (--this.health <= 0) {
        return this.destroy();
      }
    };

    return Killable;

  })(BaseEntity);

  Shot = (function(_super) {
    __extends(Shot, _super);

    function Shot() {
      _ref = Shot.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Shot.prototype.act = function() {
      this.collide_with_enemies();
      return this.explode(this.pos, 1);
    };

    Shot.prototype.collide_with_enemies = function() {
      var e, _results;
      e = this.enemies.length;
      _results = [];
      while (e-- > 0) {
        if (this.collides(this.enemies[e])) {
          this.damage(this.enemies[e]);
          this.destroy();
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Shot.prototype.damage = function(entity) {
      return entity.hit();
    };

    return Shot;

  })(Killable);

  Player_Shot = (function(_super) {
    __extends(Player_Shot, _super);

    function Player_Shot(pos, xspd) {
      this.pos = pos;
      this.vector = [xspd, -8];
      if (this.dims == null) {
        this.dims = [3, 6];
      }
      this.container = player_attacks;
      this.enemies = enemy_mobs;
      Player_Shot.__super__.constructor.apply(this, arguments);
    }

    Player_Shot.prototype.damage = function(entity) {
      Player_Shot.__super__.damage.apply(this, arguments);
      return this.inc_score();
    };

    Player_Shot.prototype.inc_score = function() {
      killcount++;
      return player.mass += 10;
    };

    return Player_Shot;

  })(Shot);

  Enemy_Shot = (function(_super) {
    __extends(Enemy_Shot, _super);

    function Enemy_Shot(pos, vector) {
      this.pos = pos;
      this.vector = vector;
      this.dims = [3, 6];
      this.container = enemy_attacks;
      this.enemies = [player];
      Enemy_Shot.__super__.constructor.apply(this, arguments);
    }

    Enemy_Shot.prototype.damage = function(entity) {
      Enemy_Shot.__super__.damage.apply(this, arguments);
      return this.explode(this.pos, 50);
    };

    return Enemy_Shot;

  })(Shot);

  Enemy_Ship = (function(_super) {
    __extends(Enemy_Ship, _super);

    function Enemy_Ship(pos, vector, cooldown) {
      this.pos = pos;
      this.vector = vector;
      this.cooldown = cooldown;
      this.dims = [25, 25];
      this.container = enemy_mobs;
      this.enemies = [player];
      Enemy_Ship.__super__.constructor.apply(this, arguments);
    }

    Enemy_Ship.prototype.act = function() {
      this.collide_with_enemies();
      if (this.cooldown-- <= 0) {
        return this.spawn_shot();
      }
    };

    Enemy_Ship.prototype.spawn_shot = function() {
      var new_shot;
      this.cooldown = 60;
      new_shot = new Enemy_Shot(this.pos.slice(0), [0, 6]);
      return new_shot.pos[1] += this.size / 2;
    };

    Enemy_Ship.prototype.render = function() {
      return dispImg(shipimg, this.pos);
    };

    return Enemy_Ship;

  })(Shot);

  Player = (function(_super) {
    __extends(Player, _super);

    function Player() {
      if (this.dims == null) {
        this.dims = [25, 25];
      }
      if (this.pos == null) {
        this.pos = [320, 350];
      }
      this.container = allies;
      this.enemies = enemy_mobs;
      if (this.mass == null) {
        this.mass = 500;
      }
      if (this.max_health == null) {
        this.max_health = 3;
      }
      this.cooldown = 0;
      Player.__super__.constructor.apply(this, arguments);
    }

    Player.prototype.update_pos = function() {
      var dirs, key, x, y, _ref1;
      _ref1 = this.pos, x = _ref1[0], y = _ref1[1];
      dirs = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = keypress.length; _i < _len; _i++) {
          key = keypress[_i];
          _results.push(key != null ? key : {
            1: 0
          });
        }
        return _results;
      })();
      x += 4 * (dirs[2] - dirs[0]);
      y += 4 * (dirs[3] - dirs[1]);
      x = this.buffer(x, this.size / 2, canvas.width - this.size / 2);
      y = this.buffer(y, this.size / 2, canvas.height - this.size / 2);
      this.pos = [x, y];
      return this.render();
    };

    Player.prototype.buffer = function(index, left, right) {
      if (index < left) {
        return left;
      }
      if (index > right) {
        return right;
      }
      return index;
    };

    Player.prototype.act = function() {
      if (this.cooldown-- <= 0 && keypress[4]) {
        return this.spawn_shot();
      }
    };

    Player.prototype.spawn_shot = function() {
      var a, left, right, shoty, side_length, x, y, _ref1, _results;
      this.cooldown = 10;
      _ref1 = this.pos, x = _ref1[0], y = _ref1[1];
      side_length = this.size / 2;
      shoty = y - side_length;
      left = x - side_length;
      right = x + side_length;
      if (killcount >= 70) {
        this.cooldown = 0;
        return new Player_Shot([x, shoty], Math.random() - .5);
      } else if (killcount >= 45) {
        a = 5;
        _results = [];
        while (a-- > 0) {
          _results.push(new Player_Shot([x, shoty], a - 2));
        }
        return _results;
      } else if (killcount >= 25) {
        new Player_Shot([left, y], -1);
        new Player_Shot([x, shoty], 0);
        return new Player_Shot([right, y], 1);
      } else if (killcount >= 10) {
        new Player_Shot([left, y], 0);
        return new Player_Shot([right, y], 0);
      } else {
        return new Player_Shot([x, shoty], 0);
      }
    };

    Player.prototype.render = function() {
      return dispImg(pcimg, this.pos);
    };

    Player.prototype.destroy = function() {
      Player.__super__.destroy.apply(this, arguments);
      return restart();
    };

    Player.prototype.hit = function() {
      this.explode([27 + 15 * this.health, canvas.height - 10], 50);
      return Player.__super__.hit.apply(this, arguments);
    };

    return Player;

  })(Killable);

  srcimg = function(src) {
    var img;
    img = document.createElement('img');
    img.src = 'http://i.imgur.com/' + src + '.png';
    return img;
  };

  canvas = document.getElementById('game');

  ctx = canvas.getContext('2d');

  pcimg = srcimg('MqaLKP2');

  meteorimg = srcimg('ChDuBLO');

  bigmeteorimg = srcimg('tIyQv1V');

  shipimg = srcimg('SbyapXR');

  bigshipimg = srcimg('nzSFj9X');

  armorimg = srcimg('pXRIDRB');

  particles = [];

  stars = [];

  player_attacks = [];

  enemy_attacks = [];

  enemy_mobs = [];

  allies = [];

  player = new Player();

  killcount = 0;

  all_entities = [['white', stars], ['grey', particles], ['white', player_attacks], ['red', enemy_attacks], ['white', enemy_mobs], ['white', allies]];

  spawntime = 60;

  spawner = 0;

  stargen = 0;

  keypress = [false, false, false, false, false];

  paused = false;

  game_loop = function() {
    if (paused) {
      return;
    }
    window.requestAnimFrame(game_loop);
    increment_spawning();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    renderEntities();
    return renderText();
  };

  renderText = function() {
    var a, _results;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'left';
    ctx.fillText('kills: ' + killcount, 5, 13);
    ctx.fillText('armor: ', 5, canvas.height - 6);
    ctx.fillStyle = 'grey';
    a = player.health;
    _results = [];
    while (a-- > 0) {
      _results.push(dispImg(armorimg, [42 + 15 * a, canvas.height - 10]));
    }
    return _results;
  };

  renderEntities = function() {
    var color, group, _i, _len, _ref1, _results;
    _results = [];
    for (_i = 0, _len = all_entities.length; _i < _len; _i++) {
      _ref1 = all_entities[_i], color = _ref1[0], group = _ref1[1];
      _results.push(render_group(color, group));
    }
    return _results;
  };

  render_group = function(color, group) {
    var a, _results;
    ctx.fillStyle = color;
    a = group.length;
    _results = [];
    while (a-- > 0) {
      _results.push(group[a].update());
    }
    return _results;
  };

  restart = function() {
    player_attacks = [];
    enemy_attacks = [];
    enemy_mobs = [];
    allies = [];
    player = new Player();
    return killcount = 0;
  };

  dispImg = function(img, pos) {
    var center_x, center_y;
    center_x = pos[0] - img.width / 2;
    center_y = pos[1] - img.height / 2;
    return ctx.drawImage(img, (center_x | 0) + .5, (center_y | 0) + .5);
  };

  increment_spawning = function() {
    var shot_offset, x, x_speed, y, y_speed;
    spawner--;
    if (spawner <= 0) {
      if (killcount >= 40) {
        spawner = spawntime / 4;
      } else if (killcount >= 15) {
        spawner = spawntime / 2;
      } else {
        spawner = spawntime;
      }
      x = Math.random() * (canvas.width - 25) + 25 / 2;
      y = -25 / 2;
      x_speed = .6 * Math.random() - .3;
      y_speed = 1.5;
      shot_offset = 30 + Math.random() * 60;
      new Enemy_Ship([x, y], [x_speed, y_speed], shot_offset);
    }
    if (stargen-- < 0) {
      stargen = 0;
      return new Star(Math.random() * canvas.width);
    }
  };

  handleKeys = function(event) {
    var a, down;
    a = -1;
    switch (event.keyCode) {
      case 37:
      case 65:
        a = 0;
        break;
      case 38:
      case 87:
        a = 1;
        break;
      case 39:
      case 68:
        a = 2;
        break;
      case 40:
      case 83:
        a = 3;
        break;
      case 32:
      case 76:
        a = 4;
    }
    down = event.type === 'keydown';
    if (a >= 0) {
      keypress[a] = down != null ? down : {
        "true": false
      };
    }
    if (event.keyCode === 80 && down) {
      toggle_pause();
    }
    event.preventDefault();
    return event.stopPropagation();
  };

  toggle_pause = function() {
    paused = !paused;
    if (paused) {
      ctx.fillStyle = 'white';
      return ctx.fillText('-paused-', canvas.width / 2 + 20, canvas.height / 2 + 5);
    } else {
      return window.requestAnimFrame(game_loop);
    }
  };

  window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
    return window.setTimeout(callback, 1000 / 60);
  };

  canvas.addEventListener('keydown', handleKeys, true);

  canvas.addEventListener('keyup', handleKeys, true);

  window.requestAnimFrame(game_loop);

}).call(this);
